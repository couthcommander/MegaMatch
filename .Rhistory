# stderr <- sqrt(stderrx^2 + stderry^2)
stderr <- sqrt(vx/nx + vy/ny)
tstat <- (mx - my)/stderr
tstat
}
system.time({
res2 <- numeric(m)
for(i in seq_along(res2)) res2[i] <- tTest(grp1[i,], grp2[i,])
})
all.equal(res, res2)
library(data.table)
head(quakes)
haversine <- function(dt) {
# decimal degrees to radians
dtnames <- names(dt)
print(dtnames)
dt[,rLat := lat * pi / 180]
dt[,rLong := long * pi / 180]
dd <- dt[,outer(rLat,rLat,`-`)]
dl <- dt[,outer(rLong,rLong,`-`)]
allLat <- t(replicate(nrow(dt), dt[,rLat]))
a <- sin(dd/2)^2 + cos(allLat) * cos(dt[,rLat]) * sin(dl/2)^2
d <- 2 * 6371000 * asin(sqrt(a))
print(dtnames)
d
}
qdt <- as.data.table(quakes)
ans <- haversine(qdt)
names(qdt)
dim(ans)
ans[1:5,1:5]
haversine <- function(dt) {
dt <- copy(dt)
# decimal degrees to radians
dtnames <- copy(names(dt))
print(dtnames)
dt[,rLat := lat * pi / 180]
dt[,rLong := long * pi / 180]
dd <- dt[,outer(rLat,rLat,`-`)]
dl <- dt[,outer(rLong,rLong,`-`)]
allLat <- t(replicate(nrow(dt), dt[,rLat]))
a <- sin(dd/2)^2 + cos(allLat) * cos(dt[,rLat]) * sin(dl/2)^2
d <- 2 * 6371000 * asin(sqrt(a))
print(dtnames)
d
}
qdt <- as.data.table(quakes)
ans <- haversine(qdt)
names(qdt)
haversine <- function(dt, latCol, longCol) {
dt <- copy(dt)
# decimal degrees to radians
dtnames <- copy(names(dt))
print(dtnames)
dt[,rLat := latCol * pi / 180]
dt[,rLong := longCol * pi / 180]
dd <- dt[,outer(rLat,rLat,`-`)]
dl <- dt[,outer(rLong,rLong,`-`)]
allLat <- t(replicate(nrow(dt), dt[,rLat]))
a <- sin(dd/2)^2 + cos(allLat) * cos(dt[,rLat]) * sin(dl/2)^2
d <- 2 * 6371000 * asin(sqrt(a))
print(dtnames)
d
}
ans <- haversine(qdt, 'lat', 'long')
# decimal degrees to radians
dtnames <- copy(names(dt))
haversine <- function(dt, latCol, longCol) {
dt <- copy(dt)
# decimal degrees to radians
dtnames <- copy(names(dt))
print(dtnames)
dt[,rLat := get(latCol) * pi / 180]
dt[,rLong := get(longCol) * pi / 180]
dd <- dt[,outer(rLat,rLat,`-`)]
dl <- dt[,outer(rLong,rLong,`-`)]
allLat <- t(replicate(nrow(dt), dt[,rLat]))
a <- sin(dd/2)^2 + cos(allLat) * cos(dt[,rLat]) * sin(dl/2)^2
d <- 2 * 6371000 * asin(sqrt(a))
print(dtnames)
d
}
ans <- haversine(qdt, 'lat', 'long')
ans[1:5,1:5]
haversine <- function(dt, latCol, longCol) {
dt <- copy(dt)
# decimal degrees to radians
dtnames <- copy(names(dt))
print(dtnames)
c1 <- deparse(substitute(latCol))
c2 <- deparse(substitute(longCol))
dt[,rLat := get(c1) * pi / 180]
dt[,rLong := get(c2) * pi / 180]
dd <- dt[,outer(rLat,rLat,`-`)]
dl <- dt[,outer(rLong,rLong,`-`)]
allLat <- t(replicate(nrow(dt), dt[,rLat]))
a <- sin(dd/2)^2 + cos(allLat) * cos(dt[,rLat]) * sin(dl/2)^2
d <- 2 * 6371000 * asin(sqrt(a))
print(dtnames)
d
}
ans <- haversine(qdt, lat, long)
ans[1:5,1:5]
haversine <- function(dt, latCol, longCol) {
dt <- copy(dt)
# decimal degrees to radians
dtnames <- copy(names(dt))
print(dtnames)
dt[,rLat := latCol * pi / 180, with = FALSE]
dt[,rLong := longCol * pi / 180, with = FALSE]
dd <- dt[,outer(rLat,rLat,`-`)]
dl <- dt[,outer(rLong,rLong,`-`)]
allLat <- t(replicate(nrow(dt), dt[,rLat]))
a <- sin(dd/2)^2 + cos(allLat) * cos(dt[,rLat]) * sin(dl/2)^2
d <- 2 * 6371000 * asin(sqrt(a))
print(dtnames)
d
}
ans <- haversine(qdt, 'lat', 'long')
grp <- sample(2, 100, replace = TRUE)
val <- rpois(100, 10)
vt <- table(val)
vt
barplot(vt)
dotchart(vt)
gvt <- table(grp, val)
vgt
gvt
barplot(gvt)
dotchart(gvt)
head(VADeaths)
# make a barplot
barplot(VADeaths)
?barplot
# discuss what's wrong
barplot(VADeaths, legend.text = TRUE)
# discuss what's wrong
barplot(VADeaths, legend.text = TRUE, beside = TRUE)
# make a dotchart
dotchart(VADeaths)
# discuss what's wrong
# can use `locator(1)` to make guess at y value
mtext('Rural\nMale', side = 2, at = 24, las = 1)
locator(1)
mtext('Rural\nFemale', side = 2, at = 17, las = 1)
mtext('Urban\nMale', side = 2, at = 10, las = 1)
mtext('Urban\nFemale', side = 2, at = 3, las = 1)
locator(4)
# conditional plot is similar to ggplot2 faceting
n <- length(dr <- c(VADeaths))
d.VAD <- data.frame(
Drate = dr,
age = rep(ordered(rownames(VADeaths)), length.out = n),
gender = gl(2, 5, n, labels = c("M", "F")),
site =  gl(2, 10, labels = c("rural", "urban"))
)
head(d.VAD)
coplot(Drate ~ as.numeric(age) | gender * site, data = d.VAD)
library(Hmisc)
points <- sample(100, 10)
points
points <- sample(100, 20)
poitns
points
sort(points)[10]
sort(points)
sort(points, decreasing = TRUE)
sort(points, decreasing = TRUE)[10]
baseline <- sort(points, decreasing = TRUE)[10]
points - baseline
table(points - baseline >= 0)
sort(points, decreasing = TRUE) - baseline
marginal <- sort(points, decreasing = TRUE) - baseline
marginal <- marginal[marginal >= 0]
marginal
marginal / sum(marginal)
Sys.getenv('RS_RPOSTBACK_PATH')
Sys.getenv('GIT_ASKPASS')
plot(1,2)
Hmisc::getHdata(diabetes
)
ggplot2::qplot(waist, weight, data = diabetes, color = gender)
plotly::ggploty(ggplot2::qplot(waist, weight, data = diabetes, color = gender))
plotly::ggplotly()
p=ggplot2::qplot(waist, weight, data = diabetes, color = gender)
plotly::ggplotly(p)
1+1
x = 1
x <- 1
x
?rnorm
?read.csv
library(Hmisc)
library(ggplot2)
getHdata(diabetes)
describe(diabetes)
qplot(waist, weight, data = diabetes, color = gender)
library(plotly)
plotly::ggploty(ggplot2::qplot(waist, weight, data = diabetes, color = gender))
p=qplot(waist, weight, data = diabetes, color = gender)
ggplotly(p)
seq(1,21, by=8)
seq_along(c(1,1,1,1,1))
getPass::getPass('huge')
?getPass::getPass
getPass::getPass
vlbw <- read.csv('https://github.com/couthcommander/Bios6301/raw/main/datasets/vlbw.csv', row.names = 1)
head(vlbw)
ggplot(vlbw, aes(gest)) + stat_ecdf()
library(ggplot2)
ggplot(vlbw, aes(gest)) + stat_ecdf()
tf <- file.path(tempdir(), 'titanic3.sav')
download.file("https://hbiostat.org/data/repo/titanic3.sav", tf)
load(tf)
head(titanic3)
ggplot(data = titanic3, aes(x = age)) + stat_ecdf()
tdat <- titanic3[complete.cases(titanic3[, c('survived','sex','age','fare')]),]
m <- glm(survived ~ sex + age + fare, data = tdat, family = binomial)
tdat[,'xSurv'] <- predict(m, type = 'response')
ggplot(data = tdat) + geom_point(aes(x = age, y = xSurv, color = survived))
# how to do this?
titanic3[,'survived'] <- factor(titanic3[,'survived'], labels = c('no','yes'))
tdat <- titanic3[complete.cases(titanic3[, c('survived','sex','age','fare')]),]
m <- glm(survived ~ sex + age + fare, data = tdat, family = binomial)
tdat[,'xSurv'] <- predict(m, type = 'response')
ggplot(data = tdat) + geom_point(aes(x = age, y = xSurv, color = survived))
?pch
remove.packages("Hmisc", lib="~/R/x86_64-pc-linux-gnu-library/4.0")
setwd("~/projects/greevy/matching_shiny")
shiny::runApp()
runApp()
list.files('../megamatch/datasets')
fh='../megamatch/datasets/henrytest.csv'
fh
jnk=read.csv(fh)
dim(jnk)
head(jnk)
fp='../megamatch/datasets/henrytest.csv'
fn=basename(fp)
fn
fp
file.access(fp)
nrecords <- as.numeric(sub("[ ]+.*$", "", (system(paste("wc -l ", fp, sep=""), intern=TRUE))))
numlines <- min(nrecords, 11)
preview <- scan(fp, sep=',', nlines=11, what='character', quiet=TRUE, na.strings=c("NA",""))
nrecords
numlines
preview
system(paste("wc -l ", fp, sep=""), intern=TRUE)
paste("wc -l ", fp, sep="")
system(paste("wc -l ", fp, sep=""))
system(paste("wc -l ", fp, sep=""), intern=TRUE)
nrecords <- as.numeric(sub("[ ]+.*$", "", (system(paste("wc -l ", fp, sep=""), intern=TRUE))))
numlines <- min(nrecords, 11)
nrecords
numlines
preview <- scan(fp, sep=',', nlines=11, what='character', quiet=TRUE, na.strings=c("NA",""))
firstlines <- matrix(preview, nrow = numlines, byrow = TRUE)
firstlines
any(is.na(suppressWarnings(as.numeric(firstlines[1,]))))
runApp()
sapply(seq(3), function(i) { tags$td(checkboxInput(sprintf('idcol_%s', i), NULL)) })
lapply(seq(3), function(i) { tags$td(checkboxInput(sprintf('idcol_%s', i), NULL)) })
jnk <- lapply(seq(3), function(i) { tags$td(checkboxInput(sprintf('idcol_%s', i), NULL)) })
str(jnk)
jnk <- lapply(seq(3), function(i) { tags$td(checkboxInput(sprintf('idcol_%s', i), NULL)) })
do.call(tags$tr, jnk)
runApp()
checkboxInput
restoreInput
?restoreInput
runApp()
c(list(width=5), list(width=10))
list(list(width=5), list(width=10))
c(list(width=5), list(width=10))
str(c(list(width=5), list(width=10)))
str(c(list(width=5), list(width=10), list(width=5, align='center')))
c(list(width=5), list(width=10), list(width=5, align='center'))
list(list(width=5), list(width=10), list(width=5, align='center'))
runApp()
list(list(width=5), list(width=10), list(width=5, align='center'))
lapply(c(5,10), function(i) list(width=i, align='center'))
c(1, lapply(c(5,10), function(i) list(width=i, align='center')))
c(huge=1, lapply(c(5,10), function(i) list(width=i, align='center')))
c(list(huge=1), lapply(c(5,10), function(i) list(width=i, align='center')))
appnd(list(huge=1), lapply(c(5,10), function(i) list(width=i, align='center')))
append(list(huge=1), lapply(c(5,10), function(i) list(width=i, align='center')))
list(huge=1)
list(huge=1, meh=0)
c(list(huge=1), list(2), lapply(c(5,10), function(i) list(width=i, align='center')))
str(c(list(huge=1), list(2), lapply(c(5,10), function(i) list(width=i, align='center'))))
str(list(list(huge=1), list(2), lapply(c(5,10), function(i) list(width=i, align='center'))))
str(c(list(list(huge=1), list(2)), lapply(c(5,10), function(i) list(width=i, align='center'))))
runApp()
colwidth=c(50,60,70)
mywidths <- list(list(list(width = 150), list(width = 10)), lapply(colwidth, function(i) list(width = i, align = 'center')))
mywidths
lapply(colwidth, function(i) list(width = i, align = 'center'))
tmp=lapply(colwidth, function(i) list(width = i, align = 'center'))
tmp
c(1, tmp)
c(1, 2, tmp)
str(c(1, 2, tmp)_
str(c(1, 2, tmp))
str(c(a=1, 2, tmp))
str(c(list(a=1), 2, tmp))
str(c(as.list(a=1), 2, tmp))
str(c(list(list(a=1)), 2, tmp))
str(c(list(list(a=1)), list(list(2)), tmp))
list(list(width = 150), list(width = 10))
mywidths <- c(list(list(width = 150), list(width = 10)), lapply(colwidth, function(i) list(width = i, align = 'center')))
mywidths
runApp()
dim(pdf)
pdf=data.frame(matrix(c('','',1:3),nrow=1))
pdf
ldf <- lapply(seq(nrow(pdf)), function(j) {
do.call(tags$tr, lapply(seq(ncol(pdf)), function(i) tags$td(pdf[j,i])))
})
ldf
r1dat <- c('Column Number', '', seq(ncol(pdf)))
r1dat
pdf=data.frame(matrix(1:3,nrow=1))
ldf <- lapply(seq(nrow(pdf)), function(j) {
do.call(tags$tr, lapply(seq(ncol(pdf)), function(i) tags$td(pdf[j,i])))
})
r1dat <- c('Column Number', '', seq(ncol(pdf)))
r1dat
ldf
pdf=data.frame(matrix(c('','',1:3),nrow=1))
pdf
ldf <- lapply(seq(nrow(pdf)), function(j) {
do.call(tags$tr, lapply(seq(ncol(pdf)), function(i) tags$td(pdf[j,i])))
})
ldf
ncol(pdf)
r1dat <- c('Column Number', '', seq_along(colnames))
r1dat
colnames
covmat=matrix(1:3, nrow=1)
covmat
colnames <- names(covmat)
colwidth <- nchar(colnames) * 15
colwidth[colwidth < 50] <- 50
mywidths <- c(list(list(width = 150), list(width = 10)), lapply(colwidth, function(i) list(width = i, align = 'center')))
ldf <- lapply(seq(nrow(pdf)), function(j) {
do.call(tags$tr, lapply(seq(ncol(pdf)), function(i) tags$td(pdf[j,i])))
})
r1dat <- c('Column Number', '', seq_along(colnames))
ldf
r1dat
colnames
covmat
names(covmat)=LETTERS[1:3]
colnames <- names(covmat)
colwidth <- nchar(colnames) * 15
colwidth[colwidth < 50] <- 50
mywidths <- c(list(list(width = 150), list(width = 10)), lapply(colwidth, function(i) list(width = i, align = 'center')))
ldf <- lapply(seq(nrow(pdf)), function(j) {
do.call(tags$tr, lapply(seq(ncol(pdf)), function(i) tags$td(pdf[j,i])))
})
r1dat <- c('Column Number', '', seq_along(colnames))
ldf
r1dat
r1 <- do.call(tags$tr, lapply(seq_along(r1dat), function(i) {
do.call(tags$td, c(r1dat[i], mywidths[[i]]))
}))
r1
r1dat <- c('Column Number', '&nbsp;', seq_along(colnames))
r1 <- do.call(tags$tr, lapply(seq_along(r1dat), function(i) {
do.call(tags$td, c(r1dat[i], mywidths[[i]]))
}))
r1
r1dat <- c('Column Number', '\\&nbsp;', seq_along(colnames))
r1 <- do.call(tags$tr, lapply(seq_along(r1dat), function(i) {
do.call(tags$td, c(r1dat[i], mywidths[[i]]))
}))
r1
runApp()
nc <- ncol(covmat)
colseq <- seq(nc)
nc <- ncol(covmat)
colseq <- seq(nc)
id.help <- "Select the column with the ID variable. The IDs may be text or numeric. If no ID column is specified, rows will be identified by row number starting with the number 1."
rank.help <- "Check any columns with variables you wish to transform into ranks. For example, suppose you wished to match on a highly skewed variable such as income. Matching on rank(income) may be preferable."
prevent.help <- "Select a column or columns with variables identifying matches to be prevented. These variables must be numeric. Any two units that have identical values for a prevent matches variable will have the distance between them set to the maximum distance. Example 1: any units may be matched except for rows 1 and 4. Solution: create a prevent matches variable 1, 2, 3, 1, 5, 6, 7, .... Example 2: match only treated units with controls units, i.e. perform optimal bipartite matching. Solution: use an indicator variable for treatment as a prevent matches variable."
weight.help <- "Provide weights to reweight the Mahalanobis distance between units. Greater weights have a proportionally greater impact on the overall distance between units. Variables for which higher quality matching is desired should get larger weights. Weights may range from 0 to infinity, with weights from 0 to 10 having performed well in the tests run to date."
missingness.help <- "Weight to be given to allow for informative missingness. Indicator variables for the missingness in variables with missing values are automatically created and the missing values are automatically filled in with single imputation via the transcan function in R. A larger weight will emphasize matching units with the same missingness patterns with each other. A smaller weight will emphasize matching units with similar imputed or observed values with each other."
discard.help <- 'Select the number of units to discard; usually zero. Suppose you have 25 potential units for a study, but only need 20. To optimally select the 5 units to drop, upload the covariate matrix for all 25 units and enter 5 for the number of units to discard. The distance matrix will be supplemented with 5 "phantom" units. The phantom units will optimally match to the 5 real units that have the lowest quality matches. When a dataset has an odd number of units and the number of units to discard is set to zero, one phantom will be created to optimally select the one unit that cannot be matched.'
helpIcon <- function(txt) sprintf('<img src="help.png" title="%s">', txt)
c2 <- 'ID Column <input type="button" value="clear" onClick="javascript:clearIdCol();">'
id_col <- sprintf("<input type='radio' name='idcol' value='%s'>", colseq)
r2dat <- c(c2, helpIcon(id.help), id_col)
r2dat
colseq
nc
covmat
r2dat
r2attr <- c(list(list(align = 'left')), lapply(seq(nc+1), function(i) list(align = 'center')))
r2attr
r2 <- do.call(tags$tr, lapply(seq_along(r2dat), function(i) {
do.call(tags$td, c(r2dat[i], r2attr[[i]]))
}))
r2
r2 <- do.call(tags$tr, c(list(bgcolor='#cccccc'), lapply(seq_along(r2dat), function(i) {
do.call(tags$td, c(r2dat[i], r2attr[[i]]))
})))
r2
?radioButtons
id_col <- lapply(colseq, function(i) { checkboxInput(sprintf('idcol_%s', i), NULL) })
id_col
r2dat <- c('ID Column', helpIcon(id.help), id_col)
r2dat
r2attr <- c(list(list(align = 'left')), lapply(seq(nc+1), function(i) list(align = 'center')))
r2 <- do.call(tags$tr, c(list(bgcolor='#cccccc'), lapply(seq_along(r2dat), function(i) {
do.call(tags$td, c(r2dat[i], r2attr[[i]]))
})))
r2\
r2
id_col <- lapply(colseq, function(i) { checkboxInput(sprintf('idcol_%s', i), NULL) })
r2dat <- c('ID Column', tags$img(src='help.png', title=id.help), id_col)
r2attr <- c(list(list(align = 'left')), lapply(seq(nc+1), function(i) list(align = 'center')))
r2 <- do.call(tags$tr, c(list(bgcolor='#cccccc'), lapply(seq_along(r2dat), function(i) {
do.call(tags$td, c(r2dat[i], r2attr[[i]]))
})))
r2dat
r2dat <- c('ID Column', list(tags$img(src='help.png', title=id.help)), id_col)
r2dat
id_col <- lapply(colseq, function(i) { checkboxInput(sprintf('idcol_%s', i), NULL) })
r2dat <- c('ID Column', list(tags$img(src='help.png', title=id.help)), id_col)
r2attr <- c(list(list(align = 'left')), lapply(seq(nc+1), function(i) list(align = 'center')))
r2 <- do.call(tags$tr, c(list(bgcolor='#cccccc'), lapply(seq_along(r2dat), function(i) {
do.call(tags$td, c(r2dat[i], r2attr[[i]]))
})))
r2
runApp()
?isolate
runApp()
covmat <- matrix(sample(25), nrow = 5)
names(covmat)
colnames(covmat)
covmat=NULL
if(is.null(covmat)) {
covmat <- matrix(sample(25), nrow = 5)
}
nc <- ncol(covmat)
nr <- nrow(covmat)
colseq <- seq(nc)
if(is.null(names(covmat))) {
names(covmat) <- colseq
}
pdf <- data.frame(cbind('', '', covmat), stringsAsFactors = FALSE)
ldf <- lapply(seq(nr), function(j) {
do.call(tags$tr, lapply(seq(ncol(pdf)), function(i) tags$td(pdf[j,i])))
})
colnames <- names(covmat)
colwidth <- nchar(colnames) * 15
colwidth[colwidth < 50] <- 50
r1attr <- c(list(list(width = 150), list(width = 10)), lapply(colwidth, function(i) list(width = i, align = 'center')))
r1dat <- c('Column Number', '', colseq)
r1 <- do.call(tags$tr, lapply(seq_along(r1dat), function(i) {
do.call(tags$td, c(r1dat[i], r1attr[[i]]))
}))
r1
ldf
c(r1, ldf)
c(list(r1), ldf)
do.call(tags$table, c(cellspacing = 0, list(r1), ldf))
runApp()
preview_help2 <- function(covmat) {
if(is.null(covmat)) {
covmat <- matrix(seq(25), nrow = 5)
}
nc <- ncol(covmat)
nr <- nrow(covmat)
colseq <- seq(nc)
if(is.null(names(covmat))) {
names(covmat) <- colseq
}
pdf <- data.frame(cbind('', '', covmat), stringsAsFactors = FALSE)
ldf <- lapply(seq(nr), function(j) {
do.call(tags$tr, lapply(seq(ncol(pdf)), function(i) tags$td(pdf[j,i])))
})
colnames <- names(covmat)
colwidth <- nchar(colnames) * 15
colwidth[colwidth < 50] <- 50
id.help <- "Select the column with the ID variable. The IDs may be text or numeric. If no ID column is specified, rows will be identified by row number starting with the number 1."
rank.help <- "Check any columns with variables you wish to transform into ranks. For example, suppose you wished to match on a highly skewed variable such as income. Matching on rank(income) may be preferable."
prevent.help <- "Select a column or columns with variables identifying matches to be prevented. These variables must be numeric. Any two units that have identical values for a prevent matches variable will have the distance between them set to the maximum distance. Example 1: any units may be matched except for rows 1 and 4. Solution: create a prevent matches variable 1, 2, 3, 1, 5, 6, 7, .... Example 2: match only treated units with controls units, i.e. perform optimal bipartite matching. Solution: use an indicator variable for treatment as a prevent matches variable."
weight.help <- "Provide weights to reweight the Mahalanobis distance between units. Greater weights have a proportionally greater impact on the overall distance between units. Variables for which higher quality matching is desired should get larger weights. Weights may range from 0 to infinity, with weights from 0 to 10 having performed well in the tests run to date."
missingness.help <- "Weight to be given to allow for informative missingness. Indicator variables for the missingness in variables with missing values are automatically created and the missing values are automatically filled in with single imputation via the transcan function in R. A larger weight will emphasize matching units with the same missingness patterns with each other. A smaller weight will emphasize matching units with similar imputed or observed values with each other."
discard.help <- 'Select the number of units to discard; usually zero. Suppose you have 25 potential units for a study, but only need 20. To optimally select the 5 units to drop, upload the covariate matrix for all 25 units and enter 5 for the number of units to discard. The distance matrix will be supplemented with 5 "phantom" units. The phantom units will optimally match to the 5 real units that have the lowest quality matches. When a dataset has an odd number of units and the number of units to discard is set to zero, one phantom will be created to optimally select the one unit that cannot be matched.'
r1attr <- c(list(list(width = 150), list(width = 10)), lapply(colwidth, function(i) list(width = i, align = 'center')))
r1dat <- c('Column Number', '', colseq)
r1 <- do.call(tags$tr, lapply(seq_along(r1dat), function(i) {
do.call(tags$td, c(r1dat[i], r1attr[[i]]))
}))
id_col <- lapply(colseq, function(i) { checkboxInput(sprintf('idcol_%s', i), NULL) })
r2dat <- c('ID Column', list(tags$img(src='help.png', title=id.help)), id_col)
r2attr <- c(list(list(align = 'left')), lapply(seq(nc+1), function(i) list(align = 'center')))
r2 <- do.call(tags$tr, c(list(bgcolor='#cccccc'), lapply(seq_along(r2dat), function(i) {
do.call(tags$td, c(r2dat[i], r2attr[[i]]))
})))
do.call(tags$table, c(cellspacing = 0, list(r1), list(r2), ldf))
}
runApp()
?checkboxInput
?numericInput
runApp()
colnames
rm(colnames)
runApp()
